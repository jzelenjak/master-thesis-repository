#!/usr/bin/env python
#
# This script plots the number of UE connections in the gNB over time:
# - The number of active RRC contexts (as they are created and removed)
# - The cumulative number of RRC contexts (only as they are created)
# The script can be used to plot connections for one or multiple experiments (based on the number of files that are provided).
#   Note that at most two experiments are currently supported, but this can be changed by modifying the relevant parts of the code.
# In order to get the csv file with the UE connections, run the script parse_gnodeb_logs.sh.

import argparse
import datetime as dt

import matplotlib.pyplot as plt
from termcolor import colored

# The file is assumed to be comma-separated (i.e. in the csv format)
FILE_SEPARATOR = ","
# The format of the timestamp in the connections file
TIME_FORMAT = "%H:%M:%S"
# The format of the output file (e.g. png, pdf, svg)
OUTPUT_FILE_EXTENSION = "pdf"

# Parameters for different elements of a figure
FONT_SIZE_TEXT = 16
FONT_SIZE_SUBTITLE = 20
FONT_SIZE_TITLE = 22
MARKER_SIZE = 8
LINE_WIDTH = 4
LINE_ALPHA = 0.6

# Elapsed seconds before the attack started
# Must be > 0, otherwise the line will not be drawn
ATTACK_START = 10

# NOTE: The logs generated by the OpenAirInterface fork use UTC time
# If you run log_stats.sh with -u option, then the time zone should be consistent
# Otherwise, you can subtract the time offset below from the start time (based on your time zone)
# TIME_OFFSET = dt.timedelta(hours=2)

# INFO: The main reason for using ArgumentParser is to be able to conveniently specify the start time if necessary
# The use of subparsers has been inspired from https://stackoverflow.com/questions/17909294/argparse-mutual-exclusive-group
parser = argparse.ArgumentParser(description="Plot the active and cumulative UE RRC connections over time")
subparsers = parser.add_subparsers(help="Specifies whether one or multiple experiments must be plotted", dest="subcommand")
# This is a subparser for plotting only one experiment
parser_one = subparsers.add_parser("plot_one", help="Plot a single experiment")
parser_one.add_argument("connections_file", type=str, metavar=("connections_exp1.csv"), \
                        help="A csv file with the UE connections. Run parse_gnodeb_logs.sh to get this file")
parser_one.add_argument("--start-time", type=str, required=False, default="", metavar=("HH:MM:SS"), \
                        help="The start time to compute elapsed seconds on the X-axis. Can be used to align the plot with the resource utilization plots (take the first timestamp obtained by running log_stats.sh). If not specified, the first timestamp from the provided file is used")
# This is a subparser for plotting multiple (currently two) experiments
parser_multiple = subparsers.add_parser("plot_multiple", help="Plot multiple experiments (currently only two are supported)")
parser_multiple.add_argument("connections_files", type=str, nargs=2, metavar=("connections_exp1.csv", "connections_exp2.csv"), \
                             help="csv files with the UE connections for Experiments 1 and 2. Run parse_gnodeb_logs.sh to get these files")
parser_multiple.add_argument("--start-times", type=str, required=False, nargs=2, default=["", ""], metavar=("HH:MM:SS", "HH:MM:SS"), \
                            help="The start times to compute elapsed seconds on the X-axis for each experiment. Can be used to align the plot with the resource utilization plots (take the first timestamp obtained by running log_stats.sh for each experiment). If not specified, the first timestamp from each provided file is used")

args = parser.parse_args()

if args.subcommand == "plot_multiple":
    INPUT_FILES = args.connections_files
    START_TIMES = args.start_times
else:
    INPUT_FILES = [args.connections_file]
    START_TIMES = [args.start_time]

if START_TIMES[0] != "":
    START_TIMES = [dt.datetime.strptime(start_time, TIME_FORMAT) for start_time in START_TIMES]
else:
    # INFO: Print a reminder message about using the first timestamp(s) in the provided file(s) as the start time
    # (To match the X-axis with the resource utilization plots created by plots_stats.py script,
    #  the start time must be taken from the stats file generated by the log_stats.sh script)
    print(colored("Warning: Start time not specified -- using the time in the provided file(s)", "yellow"))
    # INFO: Do not plot the attack start line if the start time has not been specified
    # This is done to avoid the confusion because there will be no shift
    # Feel free to comment this out if you want to always draw the attack start line
    print(colored("Warning: Start time not specified -- not drawing the attack start line", "yellow"))
    ATTACK_START = 0

# File format
#   Time,Protocol,Active_Connections,Cumulative_Connections
#   09:52:48,NR_RRC,128,1332
#   ...
experiments = []
for i, exp_file_name in enumerate(INPUT_FILES):
    protocols = dict()
    with open(exp_file_name, "r") as exp_file:
        for line in exp_file.readlines()[1:]:  # INFO: Skip the header
            parts = line.split(FILE_SEPARATOR)
            protocol_name = parts[1]
            assert protocol_name == "NR_RRC", "Only NR_RRC protocol is supported"
            if not protocol_name in protocols:
                # INFO: If not specified as the CLI option, use the first time encountered in the file
                if START_TIMES[i] == "":
                    START_TIMES[i] = dt.datetime.strptime(parts[0], TIME_FORMAT)
                protocols[protocol_name] = {"elapsed_seconds": [], "active_connections": [], "cumulative_connections": []}

            timestamp = dt.datetime.strptime(parts[0], TIME_FORMAT)
            time_diff = timestamp - START_TIMES[i]

            protocols[protocol_name]["elapsed_seconds"].append(int(time_diff.total_seconds()))
            protocols[protocol_name]["active_connections"].append(int(parts[2].strip()))
            protocols[protocol_name]["cumulative_connections"].append(int(parts[3].strip()))
    experiments.append(protocols)

# INFO: Define some values for the protocols that will be plotted
# NOTE: "color" is only used when a single experiment file has been provided
stats = {
    "active_connections": { "title": "Active RRC contexts", "color": "red", "unit": "Number of contexts" },
    "cumulative_connections": { "title": "Cumulative RRC contexts", "color": "blue", "unit": "Number of contexts" },
}

# NOTE: These values will be used if multiple experiment files have been provided
exp_colors = ["red", "blue"]
exp_labels = ["Valid IMSI", "Invalid IMSIs"]

# INFO: Take the first experiment as a reference, but plot all experiments
protocols = experiments[0]
# INFO: One plot is generated for each container
# NOTE: Currently only NR_RRC is used
for protocol_name in protocols:
    # INFO: One subplot for each metric (active_connections, cumulative_connections)
    fig, axes = plt.subplots(len(stats))
    for i, metric in enumerate(stats.keys()):
        ax = axes[i]
        max_elapsed_seconds = 45

        # INFO: Plot the metric (active/cumulative connections) for each experiment
        for index in range(len(experiments)):
            protocol = experiments[index][protocol_name]
            max_elapsed_seconds = max(max_elapsed_seconds, protocol["elapsed_seconds"][-1])
            # INFO: While not strictly needed, we can make the line start from 0,0
            if protocol["elapsed_seconds"][0] > 0:
                protocol["elapsed_seconds"].insert(0, protocol["elapsed_seconds"][0] - 1)
                protocol["elapsed_seconds"].insert(0, 0)
                # NOTE: We do this for all metrics to keep it consistent
                # This if block will only be executed once for each protocol
                for m in stats.keys():
                    protocol[m].insert(0, 0)
                    protocol[m].insert(1, 0)
            color = stats[metric]["color"] if len(experiments) == 1 else exp_colors[index]
            ax.plot(protocol["elapsed_seconds"], protocol[metric], color=color, marker='o', markersize=MARKER_SIZE, \
                    linestyle="dashed", dashes=(3 + index, 2), linewidth=LINE_WIDTH, alpha=LINE_ALPHA, label=f"Experiment {index + 1} ({exp_labels[index]})")

        # INFO: Plot the start of the attack
        if ATTACK_START > 0:
            ax.axvline(x=ATTACK_START, color="grey", linestyle="dashed", dashes=(2, 2), linewidth=LINE_WIDTH + 1, alpha=LINE_ALPHA, label="Attack start")


        ax.set_xlabel("Elapsed seconds", fontsize=FONT_SIZE_TEXT)
        ax.xaxis.set_ticks(range(0, max_elapsed_seconds + 4, 5))
        ax.set_xlim(left=0, right=max_elapsed_seconds + 1)

        ax.set_ylabel(stats[metric]["unit"], fontsize=FONT_SIZE_TEXT)
        ax.set_ylim(bottom=0)

        for tick_label in (ax.get_xticklabels() + ax.get_yticklabels()):
            tick_label.set_fontsize(FONT_SIZE_TEXT)

        # INFO: Drawing the legend for only one experiment does not make sense
        if len(experiments) > 1:
            ax.legend(fontsize=FONT_SIZE_TEXT)
        ax.set_title(stats[metric]["title"], fontsize=FONT_SIZE_SUBTITLE)
        ax.grid()

    fig.suptitle(f"Number of UE {protocol_name.replace('NR_', '')} connections stored in the gNB during the flooding attack over time", fontsize=FONT_SIZE_TITLE)

    plt.gcf().set_size_inches(20, 11, forward=True)
    plt.tight_layout()

    plt.savefig(f"connections_gnodeb_{protocol_name.lower()}.{OUTPUT_FILE_EXTENSION}")
    plt.show()
    plt.close()
