#!/usr/bin/env python
#
# This script plots the number of UE RRC connections in the gNB over time:
# - The number of active RRC contexts (as they are created and removed)
# - The cumulative number of RRC contexts (only as they are created)
# In order to get the csv file with the UE connections, run the script parse_gnodeb_logs.sh
#  (see the comments in the script file regarding the format of the logs)

import argparse
import datetime as dt

import matplotlib.dates as md
import matplotlib.pyplot as plt

# The file is assumed to be comma-separated (i.e. in the csv format)
FILE_SEPARATOR = ","
# The format of the timestamp in the stats file
TIME_FORMAT = "%H:%M:%S"

# NOTE: The logs generated by OpenAirInterface use UTC time
# If you run log_stats.sh with -u option, then the time zone should be consistent
# Otherwise, you can subtract the time offset below from the start time (based on your time zone)
# TIME_OFFSET = dt.timedelta(hours=2)

# INFO: The main reason for using ArgumentParser is to be able to conveniently specify the start time if necessary
parser = argparse.ArgumentParser(description="Plot the active and cumulative UE RRC connections over time")
parser.add_argument("connections_file", type=str, help="A csv file with the UE connections. Run parse_gnodeb_logs.sh to get this file")
parser.add_argument('--start-time', type=str, required=False, default="", metavar=("HH:MM:SS"), help="The start time for elapsed seconds on the X-axis. Use the first timestamp obtained by running log_stats.sh to align the elapsed seconds with the resource utilization plots. If not specified, the first timestamp from the connections_file is used")
args = parser.parse_args()

INPUT_FILE = args.connections_file
START_TIME = args.start_time

if args.start_time != "":
    START_TIME = dt.datetime.strptime(args.start_time, TIME_FORMAT)
else:
    # Print a reminder message about using the first time in the provided file as the start time
    # (To match the X-axis with the resource utilization plots created by plots_stats.py script,
    #  the start time must be taken from the stats file generated by the log_stats.sh script)
    print("\033[0;93mWarning: Start time not specified -- using the time in the provided file.\033[0m")


# File format
#   Time,Protocol,Active_Connections,Cumulative_Connections
#   09:52:48,NR_RRC,128,1332
#   ...
protocols = dict()
with open(INPUT_FILE, "r") as file:
    for line in file.readlines()[1:]:  # Skip the header
        parts = line.split(FILE_SEPARATOR)
        protocol = parts[1]
        assert protocol == "NR_RRC", "Only NR_RRC protocol is supported"
        if not protocol in protocols:
            # INFO: If not specified as the CLI option, use the first time encountered in the file
            if START_TIME == "":
                START_TIME = dt.datetime.strptime(parts[0], TIME_FORMAT)

            protocols[protocol] = {"time": [], "active_connections": [], "cumulative_connections": [], "elapsed_seconds": []}

        curr_time = dt.datetime.strptime(parts[0], TIME_FORMAT)
        time_diff = curr_time - START_TIME

        protocols[protocol]["elapsed_seconds"].append(int(time_diff.total_seconds()))
        protocols[protocol]["time"].append(curr_time) # Not needed, but just in case
        protocols[protocol]["active_connections"].append(int(parts[2].strip()))
        protocols[protocol]["cumulative_connections"].append(int(parts[3].strip()))


stats = {
    "active_connections": { "title": "Active RRC contexts", "color": "red", "unit": "Number of contexts" },
    "cumulative_connections": { "title": "Cumulative RRC contexts", "color": "blue", "unit": "Number of contexts" },
}

for protocol_name in protocols.keys():
    protocol = protocols[protocol_name]

    fig, axes = plt.subplots(len(stats))

    for i, metric in enumerate(stats.keys()):
        ax = axes[i]

        # Use timestamps on the X-axis (not recommended)
        # ax.xaxis.set_major_formatter(md.DateFormatter(TIME_FORMAT))
        # ax.xaxis.set_major_locator(md.SecondLocator(interval=5))
        # ax.set_xlim(START_TIME, protocol["time"][-1])
        # ax.plot(protocol["time"], protocol[metric], color=stats[metric]["color"], marker='o')

        # Use elapsed seconds on the X-axis (recommended)
        ax.set_xlabel("Elapsed seconds", fontsize=14)
        ax.xaxis.set_ticks(range(0, protocol["elapsed_seconds"][-1] + 4, 5))
        ax.set_xlim(0, protocol["elapsed_seconds"][-1] + 1)

        # While not strictly needed, we can make the line start from 0,0
        if protocol["elapsed_seconds"][0] > 0:
            protocol["elapsed_seconds"].insert(0, protocol["elapsed_seconds"][0] - 1)
            protocol["elapsed_seconds"].insert(0, 0)
            protocol[metric].insert(0, 0)
            protocol[metric].insert(1, 0)
        ax.plot(protocol["elapsed_seconds"], protocol[metric], color=stats[metric]["color"], marker='o')

        ax.set_ylabel(stats[metric]["unit"], fontsize=14)
        ax.set_ylim(bottom=0)

        for tick_label in (ax.get_xticklabels() + ax.get_yticklabels()):
            tick_label.set_fontsize(14)

        ax.set_title(stats[metric]["title"], fontsize=16)
        ax.grid()

    fig.suptitle(f"Number of UE {protocol_name.replace('NR_', '')} connections stored in the gNB during the flooding attack over time", fontsize=20)

    plt.gcf().set_size_inches(22, 12, forward=True)
    plt.tight_layout()

    plt.savefig(f"connections_{protocol_name.lower()}.png")
    plt.show()
    plt.close()
