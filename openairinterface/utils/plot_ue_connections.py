#!/usr/bin/env python
#
# This script plots the number of UE RRC connections in the gNB over time:
# - The number of established RRC connections (incremented when the UE is done processing RRCSetup and sends RRCSetupComplete + NAS Registration Request to the lower layers)
# - The number of iterations/restarts (incremented when the UE restarts the RA procedure in the RRC layer, i.e. when receiving RRCReject or DLInformationTransfer)
# The script can be used to plot the UE RRC connections for one or multiple experiments (based on the number of files that are provided).
#   Note that at most two experiments are currently supported, but this can be changed by modifying the relevant parts of the code.
# In order to get the csv file with the UE RRC connections, run the script parse_ue_logs.sh.

import argparse
import datetime as dt

import matplotlib.pyplot as plt
from termcolor import colored

# The file is assumed to be comma-separated (i.e. in the csv format)
FILE_SEPARATOR = ","
# The format of the timestamp in the connections file
TIME_FORMAT = "%H:%M:%S"
# The format of the output file (e.g. png, pdf, svg)
OUTPUT_FILE_EXTENSION = "pdf"

# Parameters for different elements of a figure
FONT_SIZE_TEXT = 16
FONT_SIZE_SUBTITLE = 20
FONT_SIZE_TITLE = 22
MARKER_SIZE = 8
LINE_WIDTH = 4
LINE_ALPHA = 0.6

# Elapsed seconds before the attack started
# Must be > 0, otherwise the line will not be drawn
ATTACK_START = 10

# NOTE: The logs generated by the OpenAirInterface fork use UTC time
# If you run log_stats.sh with -u option, then the time zone should be consistent
# Otherwise, you can subtract the time offset below from the start time (based on your time zone)
# TIME_OFFSET = dt.timedelta(hours=2)

# INFO: The main reason for using ArgumentParser is to be able to conveniently specify the start time if necessary
# The use of subparsers has been inspired from https://stackoverflow.com/questions/17909294/argparse-mutual-exclusive-group
parser = argparse.ArgumentParser(description="Plot the established RRC connections and Random Access procedure restarts by the UE over time")
subparsers = parser.add_subparsers(help="Specifies whether one or multiple experiments must be plotted", dest="subcommand")
# This is a subparser for plotting only one experiment
parser_one = subparsers.add_parser("plot_one", help="Plot a single experiment")
parser_one.add_argument("connections_file", type=str, metavar=("connections_exp1.csv"), \
                        help="A csv file with the UE RRC connections. Run parse_ue_logs.sh to get this file")
parser_one.add_argument("--start-time", type=str, required=False, default="", metavar=("HH:MM:SS"), \
                        help="The start time to compute elapsed seconds on the X-axis. Can be used to align the plot with the resource utilization plots (take the first timestamp obtained by running log_stats.sh). If not specified, the first timestamp from the provided file is used")
# This is a subparser for plotting multiple (currently two) experiments
parser_multiple = subparsers.add_parser("plot_multiple", help="Plot multiple experiments (currently only two are supported)")
parser_multiple.add_argument("connections_files", type=str, nargs=2, metavar=("connections_exp1.csv", "connections_exp2.csv"), \
                             help="csv files with the UE RRC connections for Experiments 1 and 2. Run parse_ue_logs.sh to get these files")
parser_multiple.add_argument("--start-times", type=str, required=False, nargs=2, default=["", ""], metavar=("HH:MM:SS", "HH:MM:SS"), \
                            help="The start times to compute elapsed seconds on the X-axis for each experiment. Can be used to align the plot with the resource utilization plots (take the first timestamp obtained by running log_stats.sh for each experiment). If not specified, the first timestamp from each provided file is used")

args = parser.parse_args()

if args.subcommand == "plot_multiple":
    INPUT_FILES = args.connections_files
    START_TIMES = args.start_times
else:
    INPUT_FILES = [args.connections_file]
    START_TIMES = [args.start_time]

if START_TIMES[0] != "":
    START_TIMES = [dt.datetime.strptime(start_time, TIME_FORMAT) for start_time in START_TIMES]
else:
    # INFO: Print a reminder message about using the first timestamp(s) in the provided file(s) as the start time
    # (To match the X-axis with the resource utilization plots created by plots_stats.py script,
    #  the start time must be taken from the stats file generated by the log_stats.sh script)
    print(colored("Warning: Start time not specified -- using the time in the provided file(s)", "yellow"))
    # INFO: Do not plot the attack start line if the start time has not been specified
    # This is done to avoid the confusion because there will be no shift
    # Feel free to comment this out if you want to always draw the attack start line
    print(colored("Warning: Start time not specified -- not drawing the attack start line", "yellow"))
    ATTACK_START = 0

# File format
#   Time,Total_Restarts,Established_Connections
#   19:47:08,218,64
#   ...
experiments = []
for i, exp_file_name in enumerate(INPUT_FILES):
    connections = {"elapsed_seconds": [], "total_restarts": [], "established_connections": []}
    with open(exp_file_name, "r") as exp_file:
        for line in exp_file.readlines()[1:]:  # INFO: Skip the header
            parts = line.split(FILE_SEPARATOR)
            # INFO: If not specified as the CLI option, use the first time encountered in the file
            if START_TIMES[i] == "":
                START_TIMES[i] = dt.datetime.strptime(parts[0], TIME_FORMAT)

            timestamp = dt.datetime.strptime(parts[0], TIME_FORMAT)
            time_diff = timestamp - START_TIMES[i]

            connections["elapsed_seconds"].append(int(time_diff.total_seconds()))
            connections["total_restarts"].append(int(parts[1].strip()))
            connections["established_connections"].append(int(parts[2].strip()))
    experiments.append(connections)

# INFO: Define some values for the metrics that will be plotted
# NOTE: "color" is only used when a single experiment file has been provided
stats = {
    "total_restarts": { "title": "Random Access procedure restarts in the RRC layer", "color": "red", "unit": "Number of restarts" },
    "established_connections": { "title": "Established RRC connections", "color": "blue", "unit": "Number of connections" },
}

# NOTE: These values will be used if multiple experiment files have been provided
exp_colors = ["red", "blue"]
exp_labels = ["Valid IMSI", "Invalid IMSIs"]

# INFO: One plot is generated for each metric
fig, axes = plt.subplots(len(stats))
for i, metric in enumerate(stats.keys()):
    ax = axes[i]
    max_elapsed_seconds = 45

    # INFO: Plot the metric (restarts/established connections) for each experiment
    for index in range(len(experiments)):
        conn = experiments[index]
        max_elapsed_seconds = max(max_elapsed_seconds, conn["elapsed_seconds"][-1])
        # INFO: While not strictly needed, we can make the line start from 0,0
        if conn["elapsed_seconds"][0] > 0:
            conn["elapsed_seconds"].insert(0, conn["elapsed_seconds"][0] - 1)
            conn["elapsed_seconds"].insert(0, 0)
            # NOTE: We do this for all metrics to keep it consistent
            # This if block will be executed only once for each type of connection
            for m in stats.keys():
                conn[m].insert(0, 0)
                conn[m].insert(1, 0)
        color = stats[metric]["color"] if len(experiments) == 1 else exp_colors[index]
        ax.plot(conn["elapsed_seconds"], conn[metric], color=color, marker='o', markersize=MARKER_SIZE, \
                linestyle="dashed", dashes=(3 + index, 2), linewidth=LINE_WIDTH, alpha=LINE_ALPHA, label=f"Experiment {index + 1} ({exp_labels[index]})")

    # INFO: Plot the start of the attack
    if ATTACK_START > 0:
        ax.axvline(x=ATTACK_START, color="grey", linestyle="dashed", dashes=(2, 2), linewidth=LINE_WIDTH + 1, alpha=LINE_ALPHA, label="Attack start")

    ax.set_xlabel("Elapsed seconds", fontsize=FONT_SIZE_TEXT)
    ax.xaxis.set_ticks(range(0, max_elapsed_seconds + 4, 5))
    ax.set_xlim(left=0, right=max_elapsed_seconds + 1)

    ax.set_ylabel(stats[metric]["unit"], fontsize=FONT_SIZE_TEXT)
    ax.set_ylim(bottom=0)

    for tick_label in (ax.get_xticklabels() + ax.get_yticklabels()):
        tick_label.set_fontsize(FONT_SIZE_TEXT)

    # INFO: Drawing the legend for only one experiment does not make sense
    if len(experiments) > 1:
        ax.legend(fontsize=FONT_SIZE_TEXT)
    ax.set_title(stats[metric]["title"], fontsize=FONT_SIZE_SUBTITLE)
    ax.grid()

fig.suptitle(f"Number of RRC connections established by the UE during the flooding attack over time", fontsize=FONT_SIZE_TITLE)

plt.gcf().set_size_inches(20, 11, forward=True)
plt.tight_layout()

plt.savefig(f"connections_ue.{OUTPUT_FILE_EXTENSION}")
plt.show()
plt.close()
