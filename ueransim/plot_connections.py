#!/usr/bin/env python
#
# This script plots the number of UE connections in the gNB over time:
# - The number of active RLS UDP connections (they are erased)
# - The total number of stored RRC contexts (they are not erased)
# In order to get the csv file with the UE connections, run the script parse_gnodeb_logs.sh
#  (see the comments in the script file regarding the format of the logs)

import argparse
import datetime as dt

import matplotlib.dates as md
import matplotlib.pyplot as plt

# The file is assumed to be comma-separated (i.e. in the csv format)
FILE_SEPARATOR = ","
# The format of the timestamp in the stats file
TIME_FORMAT = "%H:%M:%S"

# NOTE: The logs generated by UERANSIM seem to use UTC time
# If you run log_stats.sh with -u option, then the time zone should be consistent
# Otherwise, you can subtract the time offset below from the start time (based on your time zone)
# TIME_OFFSET = dt.timedelta(hours=2)

# INFO: The main reason for using ArgumentParser is to be able to conveniently specify the start time if necessary
parser = argparse.ArgumentParser(description="Plot the UE RLS UDP and RRC connections over time")
parser.add_argument("connections_file", type=str, help="A csv file with the UE connections. Run parse_gnodeb_logs.sh to get this file")
parser.add_argument('--start-time', type=str, required=False, default="", metavar=("HH:MM:SS"), help="The start time for elapsed seconds on the X-axis. Use the first timestamp obtained by running log_stats.sh to align the elapsed seconds with the resource utilization plots. If not specified, the first timestamp from the connections_file is used")
args = parser.parse_args()

INPUT_FILE = args.connections_file
START_TIME = args.start_time

if args.start_time != "":
    START_TIME = dt.datetime.strptime(args.start_time, TIME_FORMAT)
else:
    # Print a reminder message about using the first time in the provided file as the start time
    # (To match the X-axis with the resource utilization plots created by plots_stats.py script,
    #  the start time must be taken from the stats file generated by the log_stats.sh script)
    print("Warning: Start time not specified -- using the time in the provided file.")


# File format
#   Time,Protocol,Connections
#   13:10:26,rls-udp,129
#   13:10:26,rrc,107
#   ...
protocols = dict()
with open(INPUT_FILE, "r") as file:
    for line in file.readlines()[1:]:  # Skip the header
        parts = line.split(FILE_SEPARATOR)
        protocol = parts[1]
        if not protocol in protocols:
            # INFO: If not specified as the CLI option, use the first time encountered in the file
            if START_TIME == "":
                START_TIME = dt.datetime.strptime(parts[0], TIME_FORMAT)

            protocols[protocol] = {"time": [], "connections": [], "elapsed_seconds": []}

        curr_time = dt.datetime.strptime(parts[0], TIME_FORMAT)
        time_diff = curr_time - START_TIME

        protocols[protocol]["elapsed_seconds"].append(int(time_diff.total_seconds()))
        protocols[protocol]["time"].append(curr_time) # Not needed, but just in case
        protocols[protocol]["connections"].append(int(parts[2].strip()))


stats = {
    "rls-udp": { "title": "Active UE RLS UDP connections", "color": "red", "unit": "Number of connections", "step_size": 50 },
    "rrc": { "title": "Stored RRC contexts", "color": "blue", "unit": "Number of contexts", "step_size": 1000 },
}
# INFO: These numbers are only needed to make the Y-axis scale consistent for the two experiments
# Leave it as None if you don't need this adjustment
# ylims = { "rls-udp": 550, "rrc": 7000 }
ylims = None

fig, axes = plt.subplots(len(protocols))
for i, protocol_name in enumerate(protocols.keys()):
    protocol = protocols[protocol_name]

    ax = axes[i]

    # Use timestamps on the X-axis (not recommended)
    # ax.xaxis.set_major_formatter(md.DateFormatter(TIME_FORMAT))
    # ax.xaxis.set_major_locator(md.SecondLocator(interval=5))
    # ax.set_xlim(START_TIME, protocol["time"][-1])
    # ax.plot(protocol["time"], protocol["connections"], color=stats[protocol_name]["color"], marker='o')

    # Use elapsed seconds on the X-axis (recommended)
    ax.set_xlabel("Elapsed seconds", fontsize=14)
    ax.xaxis.set_ticks(range(0, protocol["elapsed_seconds"][-1] + 4, 5))
    ax.set_xlim(0, protocol["elapsed_seconds"][-1] + 1)
    # While not strictly needed, we can make the line start from 0,0
    if protocol["elapsed_seconds"][0] > 0:
        protocol["elapsed_seconds"].insert(0, protocol["elapsed_seconds"][0] - 1)
        protocol["elapsed_seconds"].insert(0, 0)
        protocol["connections"].insert(0, 0)
        protocol["connections"].insert(1, 0)
    ax.plot(protocol["elapsed_seconds"], protocol["connections"], color=stats[protocol_name]["color"], marker='o')

    ax.set_ylabel(stats[protocol_name]["unit"], fontsize=14)
    ax.set_ylim(bottom=0)
    # INFO: This block is only needed to make the Y-axis scale consistent for the two experiments
    if ylims is not None:
        ax.yaxis.set_ticks(range(0, ylims[protocol_name], stats[protocol_name]["step_size"]))
        ax.set_ylim(top=ylims[protocol_name])

    for tick_label in (ax.get_xticklabels() + ax.get_yticklabels()):
        tick_label.set_fontsize(14)

    ax.set_title(stats[protocol_name]["title"], fontsize=16)
    ax.grid()

fig.suptitle(f"Number of UE connections stored in the gNB during the flooding attack over time", fontsize=20)

plt.gcf().set_size_inches(22, 12, forward=True)
plt.tight_layout()

plt.savefig(f"connections.pdf")
plt.show()
plt.close()
